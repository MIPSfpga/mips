<p><b>3.1 Review</b></p>

<p>Review</p>

<blockquote><p>File <i>programs/02_light_sensor/main.c</i></p><pre>

#include "mfp_memory_mapped_registers.h"

int main ()
{
    int n = 0;

    for (;;)
    {
        MFP_RED_LEDS      = MFP_LIGHT_SENSOR &gt;&gt; 4;
        MFP_7_SEGMENT_HEX = MFP_LIGHT_SENSOR;
        MFP_GREEN_LEDS    = n ++;
    }

    return 0;
}
</pre></blockquote>

<p><b>3.1 Review</b></p>

<p>Review</p>

<blockquote><p>File <i>programs/02_light_sensor/mfp_memory_mapped_registers.h</i></p><pre>

#ifndef MFP_MEMORY_MAPPED_REGISTERS_H
#define MFP_MEMORY_MAPPED_REGISTERS_H

#define MFP_RED_LEDS_ADDR       0xBF800000
#define MFP_GREEN_LEDS_ADDR     0xBF800004
#define MFP_SWITCHES_ADDR       0xBF800008
#define MFP_BUTTONS_ADDR        0xBF80000C
#define MFP_7_SEGMENT_HEX_ADDR  0xBF800010
#define MFP_LIGHT_SENSOR_ADDR   0xBF800014

#define MFP_RED_LEDS            (* (volatile unsigned *) MFP_RED_LEDS_ADDR      )
#define MFP_GREEN_LEDS          (* (volatile unsigned *) MFP_GREEN_LEDS_ADDR    )
#define MFP_SWITCHES            (* (volatile unsigned *) MFP_SWITCHES_ADDR      )
#define MFP_BUTTONS             (* (volatile unsigned *) MFP_BUTTONS_ADDR       )
#define MFP_7_SEGMENT_HEX       (* (volatile unsigned *) MFP_7_SEGMENT_HEX_ADDR )
#define MFP_LIGHT_SENSOR        (* (volatile unsigned *) MFP_LIGHT_SENSOR_ADDR  )
</pre></blockquote>

<p><b>3.1 Review</b></p>

<p>Review</p>

<blockquote><p>File <i>system_rtl/mfp_pmod_als_spi_receiver.v</i></p><pre>

module mfp_pmod_als_spi_receiver
(
    input             clock,
    input             reset_n,
    output            cs,
    output            sck,
    input             sdo,
    output reg [15:0] value
);

    reg [21:0] cnt;
    reg [15:0] shift;

    always @ (posedge clock or negedge reset_n)
    begin       
        if (! reset_n)
            cnt &lt;= 22'b100;
        else
            cnt &lt;= cnt + 22'b1;
    end

    assign sck = ~ cnt [3];
    assign cs  =   cnt [8];

    wire sample_bit = ( cs == 1'b0 && cnt [3:0] == 4'b1111 );
    wire value_done = ( cnt [21:0] == 22'b0 );

    always @ (posedge clock or negedge reset_n)
    begin       
        if (! reset_n)
        begin       
            shift &lt;= 16'h0000;
            value &lt;= 16'h0000;
        end
        else if (sample_bit)
        begin       
            shift &lt;= (shift &lt;&lt; 1) | sdo;
        end
        else if (value_done)
        begin       
            value &lt;= shift;
        end
    end

endmodule
</pre></blockquote>

<p><b>3.1 Review</b></p>

<p>Review</p>

<blockquote><p>File <i>boards/nexys4_ddr/nexys4_ddr.v</i></p><pre>

module nexys4_ddr
(
    input         CLK100MHZ,
    input         CPU_RESETN,

    . . . . . . . . . . . . . . . . . . . .

    inout  [12:1] JA,
    inout  [12:1] JB,

    . . . . . . . . . . . . . . . . . . . .
);

    . . . . . . . . . . . . . . . . . . . .

    mfp_system mfp_system
    (
        .SI_ClkIn         (   clk           ),
        .SI_Reset         ( ~ CPU_RESETN    ),
                          
        . . . . . . . . . . . . . . . . . .

        .SPI_CS           (   JA [ 1]       ),
        .SPI_SCK          (   JA [ 4]       ),
        .SPI_SDO          (   JA [ 3]       )
    );

    assign JA [7] = 1'b0;
</pre></blockquote>

<p><b>3.1 Review</b></p>

<p>Review</p>

<blockquote><p>File <i>boards/de0_cv/de0_cv.v</i></p><pre>

module de0_cv
(
    input           CLOCK2_50,
    input           CLOCK3_50,
    inout           CLOCK4_50,
    input           CLOCK_50,
                   
    input           RESET_N,

    . . . . . . . . . . . . . . . . . . . .

    inout   [35:0]  GPIO_0,
    inout   [35:0]  GPIO_1
);

    . . . . . . . . . . . . . . . . . . . .

    mfp_system mfp_system
    (
        .SI_ClkIn         (   clk             ),
        .SI_Reset         ( ~ RESET_N         ),
                          
        . . . . . . . . . . . . . . . . . .

        .SPI_CS           (   GPIO_1 [34]     ),
        .SPI_SCK          (   GPIO_1 [28]     ),
        .SPI_SDO          (   GPIO_1 [30]     )
    );

    . . . . . . . . . . . . . . . . . . . .

    assign GPIO_1 [26] = 1'b0;
</pre></blockquote>

<p><b>3.1 Review</b></p>

<p>Review</p>

<blockquote><p>File <i>system_rtl/mfp_ahb_lite_matrix_config.vh</i></p><pre>

//
//  Configuration parameters
//

// `define MFP_USE_WORD_MEMORY
// `define MFP_INITIALIZE_MEMORY_FROM_TXT_FILE
// `define MFP_USE_SLOW_CLOCK_AND_CLOCK_MUX
`define MFP_USE_UART_PROGRAM_LOADER
`define MFP_DEMO_LIGHT_SENSOR
// `define MFP_DEMO_INTERRUPTS
// `define MFP_DEMO_CACHE_MISSES
// `define MFP_DEMO_PIPE_BYPASS

//
//  Memory-mapped I/O addresses
//

. . . . . . . . . . . . . . . . . . . . . .

`define MFP_RED_LEDS_ADDR           32'h1f800000
`define MFP_GREEN_LEDS_ADDR         32'h1f800004
`define MFP_SWITCHES_ADDR           32'h1f800008
`define MFP_BUTTONS_ADDR            32'h1f80000C
`define MFP_7_SEGMENT_HEX_ADDR      32'h1f800010

`ifdef MFP_DEMO_LIGHT_SENSOR
`define MFP_LIGHT_SENSOR_ADDR       32'h1f800014
`endif

`define MFP_RED_LEDS_IONUM          4'h0
`define MFP_GREEN_LEDS_IONUM        4'h1
`define MFP_SWITCHES_IONUM          4'h2
`define MFP_BUTTONS_IONUM           4'h3
`define MFP_7_SEGMENT_HEX_IONUM     4'h4
                                    
`ifdef MFP_DEMO_LIGHT_SENSOR            
`define MFP_LIGHT_SENSOR_IONUM      4'h5
`endif
</pre></blockquote>

<p><b>3.1 Review</b></p>

<p>Review</p>

<blockquote><p>File <i>system_rtl/mfp_system.v</i></p><pre>

module mfp_system
(
    input         SI_ClkIn,
    input         SI_ColdReset,
    input         SI_Reset,

    . . . . . . . . . . . . . . . . . . . .

    output        SPI_CS,
    output        SPI_SCK,
    input         SPI_SDO
);

    . . . . . . . . . . . . . . . . . . . .

    `ifdef MFP_DEMO_LIGHT_SENSOR
    wire [15:0] IO_LightSensor;
    `endif

    mfp_ahb_lite_matrix_with_loader ahb_lite_matrix
    (
        .HCLK             (   HCLK             ),
        .HRESETn          ( ~ SI_Reset         ),  // Not HRESETn - this is necessary for serial loader
                                               
        . . . . . . . . . . . . . . . . . .

        `ifdef MFP_DEMO_LIGHT_SENSOR           
        .IO_LightSensor   (   IO_LightSensor   ), 
        `endif                                 
                                               
        . . . . . . . . . . . . . . . . . .

    );

    `ifdef MFP_DEMO_LIGHT_SENSOR

    mfp_pmod_als_spi_receiver mfp_pmod_als_spi_receiver
    (
        .clock   (   SI_ClkIn       ),
        .reset_n ( ~ SI_Reset       ),
        .cs      (   SPI_CS         ),
        .sck     (   SPI_SCK        ),
        .sdo     (   SPI_SDO        ),
        .value   (   IO_LightSensor )
    );

    `endif
</pre></blockquote>

<p><b>3.1 Review</b></p>

<p>Review</p>

<blockquote><p>File <i>system_rtl/mfp_ahb_lite_matrix_with_loader.v</i></p><pre>

module mfp_ahb_lite_matrix_with_loader
(
    input         HCLK,
    input         HRESETn,

    . . . . . . . . . . . . . . . . . . . .

    `ifdef MFP_DEMO_LIGHT_SENSOR
    input  [15:0] IO_LightSensor,
    `endif

    . . . . . . . . . . . . . . . . . . . .
);

    . . . . . . . . . . . . . . . . . . . .

    mfp_ahb_lite_matrix ahb_lite_matrix
    (
        .HCLK             ( HCLK            ),
        .HRESETn          ( HRESETn         ),
                         
        . . . . . . . . . . . . . . . . . .

        `ifdef MFP_DEMO_LIGHT_SENSOR
        .IO_LightSensor   ( IO_LightSensor  ), 
        `endif
                                       
        . . . . . . . . . . . . . . . . . .
    );
</pre></blockquote>

<p><b>3.1 Review</b></p>

<p>Review</p>

<blockquote><p>File <i>system_rtl/mfp_ahb_lite_matrix.v</i></p><pre>

module mfp_ahb_lite_matrix
(
    input         HCLK,
    input         HRESETn,

    . . . . . . . . . . . . . . . . . . . .

    `ifdef MFP_DEMO_LIGHT_SENSOR
    input  [15:0] IO_LightSensor,
    `endif

    . . . . . . . . . . . . . . . . . . . .
);

    . . . . . . . . . . . . . . . . . . . .

    mfp_ahb_gpio_slave gpio
    (
        .HCLK             ( HCLK            ),
        .HRESETn          ( HRESETn         ),

        . . . . . . . . . . . . . . . . . .

        `ifdef MFP_DEMO_LIGHT_SENSOR
        ,
        .IO_LightSensor   ( IO_LightSensor  )
        `endif
    );
</pre></blockquote>

<p><b>3.1 Review</b></p>

<p>Review</p>

<blockquote><p>File <i>mfp_ahb_gpio_slave.v</i></p><pre>

`include "mfp_ahb_lite.vh"
`include "mfp_ahb_lite_matrix_config.vh"

module mfp_ahb_gpio_slave
(
    input             HCLK,
    input             HRESETn,
    input      [31:0] HADDR,
    input      [ 2:0] HBURST,
    input             HMASTLOCK,
    input      [ 3:0] HPROT,
    input      [ 2:0] HSIZE,
    input             HSEL,
    input      [ 1:0] HTRANS,
    input      [31:0] HWDATA,
    input             HWRITE,
    output reg [31:0] HRDATA,
    output            HREADY,
    output            HRESP,
    input             SI_Endian,
               
    input      [`MFP_N_SWITCHES          - 1:0] IO_Switches,
    input      [`MFP_N_BUTTONS           - 1:0] IO_Buttons,
    output reg [`MFP_N_RED_LEDS          - 1:0] IO_RedLEDs,
    output reg [`MFP_N_GREEN_LEDS        - 1:0] IO_GreenLEDs,
    output reg [`MFP_7_SEGMENT_HEX_WIDTH - 1:0] IO_7_SegmentHEX

    `ifdef MFP_DEMO_LIGHT_SENSOR
    ,
    input      [15:0] IO_LightSensor
    `endif
);

    // Ignored: HMASTLOCK, HPROT
    // TODO: SI_Endian

    // Assignments to HREADY and HTRANS should be modified
    // for more complicated peripherals

    assign HREADY = 1'b1;
    assign HRESP  = 1'b0;

    reg [ 1:0] HTRANS_dly;
    reg [31:0] HADDR_dly;
    reg        HWRITE_dly;
    reg        HSEL_dly;

    always @ (posedge HCLK)
    begin
        HTRANS_dly &lt;= HTRANS;
        HADDR_dly  &lt;= HADDR;
        HWRITE_dly &lt;= HWRITE;
        HSEL_dly   &lt;= HSEL;
    end

    wire [3:0] read_ionum   = HADDR     [5:2];
    wire [3:0] write_ionum  = HADDR_dly [5:2];
    wire       write_enable = HTRANS_dly != `HTRANS_IDLE && HSEL_dly && HWRITE_dly;

    always @ (posedge HCLK or negedge HRESETn)
    begin
        if (! HRESETn)
        begin
            IO_RedLEDs      &lt;= `MFP_N_RED_LEDS'b0;
            IO_GreenLEDs    &lt;= `MFP_N_GREEN_LEDS'b0;
            IO_7_SegmentHEX &lt;= `MFP_7_SEGMENT_HEX_WIDTH'b0;
        end
        else if (write_enable)
        begin
            case (write_ionum)
            `MFP_RED_LEDS_IONUM      : IO_RedLEDs      &lt;= HWDATA [`MFP_N_RED_LEDS          - 1:0];
            `MFP_GREEN_LEDS_IONUM    : IO_GreenLEDs    &lt;= HWDATA [`MFP_N_GREEN_LEDS        - 1:0];
            `MFP_7_SEGMENT_HEX_IONUM : IO_7_SegmentHEX &lt;= HWDATA [`MFP_7_SEGMENT_HEX_WIDTH - 1:0];
            endcase
        end
    end

    always @ (posedge HCLK or negedge HRESETn)
    begin
        if (! HRESETn)
        begin
            HRDATA &lt;= 32'h00000000;
        end
        else
        begin
            case (read_ionum)
            `MFP_SWITCHES_IONUM      : HRDATA &lt;= { { 32 - `MFP_N_SWITCHES { 1'b0 } } , IO_Switches };
            `MFP_BUTTONS_IONUM       : HRDATA &lt;= { { 32 - `MFP_N_BUTTONS  { 1'b0 } } , IO_Buttons  };
            
            `ifdef MFP_DEMO_LIGHT_SENSOR
            `MFP_LIGHT_SENSOR_IONUM  : HRDATA &lt;= { 16'b0, IO_LightSensor };
            `endif
            
            default:                   HRDATA &lt;= 32'h00000000;
            endcase
        end
    end

endmodule
</pre></blockquote>

<p><b>3.1 Review</b></p>

<p>Review</p>

<blockquote><p>File <i>system_rtl/mfp_seven_segment_displays.v</i></p><pre>

module mfp_single_digit_seven_segment_display
(
    input      [3:0] digit,
    output reg [6:0] seven_segments
);

    always @*
        case (digit)
        'h0: seven_segments = 'b1000000;  // a b c d e f g
        'h1: seven_segments = 'b1111001;
        'h2: seven_segments = 'b0100100;  //   --a--
        'h3: seven_segments = 'b0110000;  //  |     |
        'h4: seven_segments = 'b0011001;  //  f     b
        'h5: seven_segments = 'b0010010;  //  |     |
        'h6: seven_segments = 'b0000010;  //   --g--
        'h7: seven_segments = 'b1111000;  //  |     |
        'h8: seven_segments = 'b0000000;  //  e     c
        'h9: seven_segments = 'b0011000;  //  |     |
        'ha: seven_segments = 'b0001000;  //   --d-- 
        'hb: seven_segments = 'b0000011;
        'hc: seven_segments = 'b1000110;
        'hd: seven_segments = 'b0100001;
        'he: seven_segments = 'b0000110;
        'hf: seven_segments = 'b0001110;
        endcase

endmodule

//--------------------------------------------------------------------

module mfp_multi_digit_display
(
    input             clock,
    input             resetn,
    input      [31:0] number,

    output reg [ 6:0] seven_segments,
    output reg        dot,
    output reg [ 7:0] anodes
);

    function [6:0] bcd_to_seg (input [3:0] bcd);

        case (bcd)
        'h0: bcd_to_seg = 'b1000000;  // a b c d e f g
        'h1: bcd_to_seg = 'b1111001;
        'h2: bcd_to_seg = 'b0100100;  //   --a--
        'h3: bcd_to_seg = 'b0110000;  //  |     |
        'h4: bcd_to_seg = 'b0011001;  //  f     b
        'h5: bcd_to_seg = 'b0010010;  //  |     |
        'h6: bcd_to_seg = 'b0000010;  //   --g--
        'h7: bcd_to_seg = 'b1111000;  //  |     |
        'h8: bcd_to_seg = 'b0000000;  //  e     c
        'h9: bcd_to_seg = 'b0011000;  //  |     |
        'ha: bcd_to_seg = 'b0001000;  //   --d-- 
        'hb: bcd_to_seg = 'b0000011;
        'hc: bcd_to_seg = 'b1000110;
        'hd: bcd_to_seg = 'b0100001;
        'he: bcd_to_seg = 'b0000110;
        'hf: bcd_to_seg = 'b0001110;
        endcase

    endfunction

    reg [2:0] i;

    always @ (posedge clock or negedge resetn)
    begin
        if (! resetn)
        begin
            seven_segments &lt;=   bcd_to_seg (0);
            dot            &lt;= ~ 0;
            anodes         &lt;= ~ 8'b00000001;

            i &lt;= 0;
        end
        else
        begin
            seven_segments &lt;=   bcd_to_seg (number [i * 4 +: 4]);
            dot            &lt;= ~ 0;
            anodes         &lt;= ~ (1 &lt;&lt; i);

            i &lt;= i + 1;
        end
    end

endmodule
</pre></blockquote>
