<p><big><b>1.  Introduction</b></big></p>

<p>This lab introduces switchable clock, a feature of MIPSfpga 2.0 that
enables the whole new category of student labs.  With this feature you can
first run the processor with its usual multi megahertz frequency, then
switch it to the frequence of a few clocks per second and observe how the
processor works live.  A typical usage is to connect to external LEDs the
CPU signals that control cache evictions or pipeline forwarding and observe
the LED patterns when running different sequence of code.  This usage is
demonstrated in <i>MIPSfpga 2.0.  Lab YP5 - The first glance into caches</i>
and <i>MIPSfpga 2.0.  Lab YP6 - The first glance into pipelining</i></p>



<a href="http://silicon-russia.com/pages/2015_12_28/hierarchy_nexys4_ddr__narrow_write_support__light_sensor__serial_loader__switchable_clock.html"><img src="http://silicon-russia.com/pages/2015_12_28/hierarchy_nexys4_ddr__narrow_write_support__light_sensor__serial_loader__switchable_clock.png"></a>

<h3>5.1. Switchable clock implementation</h3>

A few words about MIPS microAptiv UP frequencies.

When implemented in ASIC using 28 nm technology, MIPS microAptiv UP can run up to 500 MHz; when implemented using 65 nm - more than 300 MHz.

When MIPS microAptiv UP is synthesized for FPGA, the frequency is much lower - around 50-60 MHz, both for Xilinx and Altera.

The introductory student boards tested for MIPSfpga all have clock generators able to generate a clock signal with the frequency of 50-100 MHz. This frequency can be increased or decreased using phase-locked loop (PLL). Unfortunately, PLL cannot be used to lower the frequency below approximately 100 KHz. In order to lower the frequency even further, other methods have to be used.

Altera has a special macro for such situation called <i>ALTCLKCTLR</i>, but for some reason it did not work. As a result, the switchable clock got implemented using a combination of a counter and a global buffer (Xilinx macro <i>BUFG</i> and Altera macro <i>global</i>).

The frequency is controlled by two switches. Switches also have to be debounced.

This is how switchable clock is instantiated for Xilinx:

<a href="http://www.silicon-russia.com/wp-content/uploads/2016/01/Screenshot-2015-12-31-23.10.58.png" rel="attachment wp-att-681"><img src="http://www.silicon-russia.com/wp-content/uploads/2016/01/Screenshot-2015-12-31-23.10.58.png" class="alignnone size-full wp-image-681" /></a>

This is how switchable clock is instantiated for Xilinx:

<a href="http://www.silicon-russia.com/wp-content/uploads/2016/01/Screenshot-2015-12-31-23.11.35.png" rel="attachment wp-att-682"><img src="http://www.silicon-russia.com/wp-content/uploads/2016/01/Screenshot-2015-12-31-23.11.35.png" class="alignnone size-large wp-image-682" /></a>

The modules with a counter:

<a href="http://www.silicon-russia.com/wp-content/uploads/2016/01/Screenshot-2015-12-31-23.13.22.png" rel="attachment wp-att-683"><img src="http://www.silicon-russia.com/wp-content/uploads/2016/01/Screenshot-2015-12-31-23.13.22.png" class="alignnone size-large wp-image-683" /></a>

The whole thing also requires adding appropriate constrains. It is possible these constraints are not perfect right now and require more work. Incomplete constraints may be the reason switchable clock works well on Nexys 4 DDR and Terasic DE0-CV, but fails on some systems with Terasic DE0-Nano.

<h3>5.2. An example of student experiment: switchable clock enables to directly observe CPU cache in action</h3>

Switchable clock allows to show the internals of the processor to the students live. Here is an example: a signal that indicates cache eviction is connected to an external LED. Now it is possible to observe cache misses when a program fills a two-dimensional array. This example can be run twice: when the array is filled by columns and when the array is filled by rows. These runs generate different patters of LED blinking.



<p>In this lab you will review and synthesize a configuration of MIPSfpga
system that contains a peripheral - Digilent Pmod ALS, the Ambient Light
Sensor. In order to integrate a new peripheral into MIPSfpga system, you
have to go through three main steps:</p>

<ol>

<li>Design a Verilog module that handles the external protocol used to
communicate to the peripheral. The protocol used in this lab is Serial
Peripheral Interface (SPI).</li>

<li>Create glue logic used to interface the above module with AHB-Lite,
on-chip bus fabric, used in MIPSfpga system.</li>

<li>Write software support that allows the application program running on
MIPS microAptiv UP core inside MIPSfpga system to drive the peripheral using
the corresponding memory-mapped input/output registers.</li>

</ol>

<p>By going through this lab you will understand the fundamental difference
between on-chip buses (AHB, AXI, OCP) and inter-chip buses (SPI, UART,
I<sup>2</sup>C), as well as differences between serial buses and parallel
buses. SPI bus used to communicate with the sensor is an example of a serial
bus, while AHB-Lite used in MIPSfpga SoC is an example of a parallel
bus.</p>

<p>The result of light intensity, measured in this lab, is displayed on a
multiple-digit seven-segment display. By combining a sensor, a system
controller and an output device (the display) you will construct a
practically useful gadget, a light meter.</p>

<p>This lab can be further combined with the next lab, <i> MIPSfpga 2.0. 
Lab YP4 - Introducing interrupts</i>, to demonstrate the interrupt-driven
approach to input/output used in many real embedded systems.</p>
