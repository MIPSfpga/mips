<html>
<head>

<title>
MIPSfpga 2.0. Lab YP3 - Introducing interrupts
</title>

<style>

a, body, th, td
{
    font-family : 'Lucida Sans Unicode', 'Lucida Grande', sans-serif;
    font-size   : 12px;
}

pre
{
    font-family : 'Lucida Console', Monaco, monospace;
    font-size   : 12px;
}

</style>
</head>
<body>

<p><big><big><b>
MIPSfpga 2.0. Lab YP3 - Introducing interrupts
</b></big></big></p>
<p><big><b>1.  Introduction</b></big></p>

<p><big><b>2.  The theory of operation</b></big></p>

<p>Interrupt is one of the key concepts in computer programming and system
design.  Interrupt is basically a feature of a CPU that forces the processor
to suspend the regular flow of instruction execution and to jump to a
certain program address in response to some external event.  The external
event is usually a change in a hardware signal from outside of the CPU.  The
memory location (or, in some processors, an index in an array of memory
locations) where the processor jumps to, is called the interrupt vector. 
The piece of code where the control goes after landing on the interrupt
vector, is called the interrupt service routine, or ISR.  After the ISR is
executed, the control goes back to the program location that was executed by
the processor when it received the interrupt.</p>

<p>The external event that causes the interrupt can be a tick of a timer
clock.  Such timer interrupts are useful to organize task switching in a
system where several software tasks, or programs, share the same processor,
which switches between them.  Another example of an external event that
causes an interrupt is a signal about the completion of an input/output
operation.  Such I/O interrupts are useful to offload the regular program
flow from constant polling of I/O registers, checking their status, as shown
on <b><font color=blue>Figure 1</font></b>.</p>

<center>

<p><b><font color=blue>Figure 1.  The action of an I/O interrupt.</font></b>
The source of the figure: <a
href="http://virtualirfan.com/history-of-interrupts">http://virtualirfan.com/history-of-interrupts</a>.</p>

<img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/WhatIsAnInterrupt.png"
/>

</center>

<p>Interrupt, sometimes called more specifically hardware interrupt, is a
special case of a more general term "exception".  An exception is suspending
the regular instruction flow and jumping to a vector in response not only to
an external signal, but also to some internal conditions of the CPU, the
conditions that require immediate attention.  Such conditions include
errors: arithmetic overflows, accessing out of range address, running a
privileged instruction in non-privileged (user) mode, bus errors, and other
unusual conditions.  Some of those errors should terminate the offending
program, while others should cause the program to recover, though the action
of the exception service routine.  Some of those conditions, like memory
address exceptions, may be not considered errors at all, but parts of the
mechanics of virtual memory implementation.  There are also so-called
software interrupts, the exceptions that are intentionally caused by the
program to request the services of the operating system.  Exceptions are
also used in the processor's debug interface.  During this lab we will deal
strictly with "true" hardware interrupts.  To learn about the other aspects
of exceptions, please consult the core and architecture documentation.</p>

<p>Historically, the need for exceptions and interrupts was so obvious that
they appeared very early in the history of computers, as shown on <b><font
color=blue>Figure 2</font></b>.</p>

<center>

<p><b><font color=blue>Figure 2.  The history of exceptions and
interrupts.</font></b> The source of the figure: <a
href="http://virtualirfan.com/history-of-interrupts">http://virtualirfan.com/history-of-interrupts</a>.</p>

<img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/HistoryOfInterrupts.png"
/>

</center>

<p>According to the article <i>Interrupts</i> by Mark Smotherman (<a
href="https://people.cs.clemson.edu/~mark/interrupts.html#dyseac">https://people.cs.clemson.edu/~mark/interrupts.html#dyseac</a>),
the first computer that employed I/O interrupts was DYSEAC, the second
version of SEAC, the Standards Electronic Automatic Computer.  According to
Wikipedia (<a
href="https://en.wikipedia.org/wiki/DYSEAC">https://en.wikipedia.org/wiki/DYSEAC</a>),
"DYSEAC was a first-generation computer built by the National Bureau of
Standards for the US Army Signal Corps.  It went into operation in April
1954".  According to Smotherman, DYSEAC was perhaps also the first mobile
computer, carried in two tractor trailers at 12 and 8 tons, as shown on
<b><font color=blue>Figure 3</font></b>.</p>

<center>

<p><b><font color=blue>Figure 3.  DYSEAC, the first computer with I/O
interrupts.</font></b> The source of the figure: <a
href="http://ed-thelen.org/comp-hist">http://ed-thelen.org/comp-hist</a>.</p>

<img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/BRL61-0234.jpg"
/>

</center>

<p><big><b>3. Lab steps</b></big></p>

<p>This section outlines the sequence of steps, necessary to complete the
lab.  Almost all generic steps in this lab are the same as in <i>MIPSfpga
2.0 Lab YP1.  Using MIPSfpga with Serial Loader Flow that does not require
BusBlaster board and OpenOCD software</i>.  Such generic steps are not
described in this section.  Only the steps different from <i>Lab YP1</i> are
explained in details.</p>

<p><big><b>3.4. Review lab code modifications in <i>system_rtl</i> and
<i>testbench</i> directories</b></big></p>

<p>Search for <i>MFP_DEMO_PIPE_BYPASS</i> symbol in <i>system_rtl</i> and
<i>testbench</i> directories. Review the code fragments where that symbol
occurs.</p>

<p>Modify the configuration parameters in the file
<i>system_rtl/mfp_ahb_lite_matrix_config.vh</i> as follows:</p>

<blockquote><pre>

//
//  Configuration parameters
//

// `define MFP_USE_WORD_MEMORY
// `define MFP_INITIALIZE_MEMORY_FROM_TXT_FILE
   `define MFP_USE_SLOW_CLOCK_AND_CLOCK_MUX
   `define MFP_USE_UART_PROGRAM_LOADER
// `define MFP_DEMO_LIGHT_SENSOR
// `define MFP_DEMO_CACHE_MISSES
   `define MFP_DEMO_PIPE_BYPASS

</pre></blockquote>

<p>Review the following fragments of <i>system_rtl/mfp_system.v</i>:</p>

<blockquote><pre>
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

`ifdef MFP_DEMO_PIPE_BYPASS
    wire         mpc_aselres_e;
    wire         mpc_aselwr_e;
    wire         mpc_bselall_e;
    wire         mpc_bselres_e;
`endif

    m14k_top m14k_top
    (

        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

        .UDI_toudi             ( UDI_toudi             )

`ifdef MFP_DEMO_PIPE_BYPASS
        ,
        .mpc_aselres_e         ( mpc_aselres_e         ),     
        .mpc_aselwr_e          ( mpc_aselwr_e          ),     
        .mpc_bselall_e         ( mpc_bselall_e         ),     
        .mpc_bselres_e         ( mpc_bselres_e         )      
`endif

    );

    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

    `ifdef MFP_DEMO_CACHE_MISSES

    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

    `elsif MFP_DEMO_PIPE_BYPASS

    assign IO_GreenLEDs = { { `MFP_N_GREEN_LEDS - 5 { 1'b0 } },

        HCLK,
        mpc_aselres_e,  // Bypass res_m as src A
        mpc_bselres_e   // Bypass res_m as src B
        mpc_aselwr_e,   // Bypass res_w as src A
        mpc_bselall_e,  // Bypass res_w as src B
    };

    `endif

</pre></blockquote>

<p><big><b>3.5.  Connect the board to the computer</b></big></p>

<p>For <i>Digilent</i> boards, such as <i>Nexys4</i>, <i>Nexys4 DDR</i> or
<i>Basys3</i>, this step is obvious.  For <i>Altera/Terasic</i> boards some
additional steps required:</p>

<ol>

<li>Connect USB-to-UART connector to FPGA board.  Either <i>FT232RL</i> or
<i>PL2303TA</i> that you can by from AliExpress or Radio Shack will do the
job.  <i>TX</i> output from the connector (green wire on <i>PL2303TA</i>)
should go to pin 3 from right bottom on Terasic DE0, DE0-CV, DE1, DE2-115
(right top on DE0-Nano) and <i>GND</i> output (black wire on
<i>PL2303TA</i>) should be connected to pin 6 from right bottom on Terasic
DE0, DE0-CV, DE1, DE2-115 (right top on DE0-Nano).  Please consult photo
picture in <i>Lab YP1</i> to avoid short-circuit or other connection
problems.</li>

<li>For <i>FT232RL</i> connector: make sure to set 3.3V/5V jumper on
<i>FT232RL</i> part to 3.3V.</li>

<li>For the boards that require external power in addition to the power that
comes from USB, connect the power supply.  The boards that require the extra
power supply include <i>Terasic DE2-115</i>.</li>

<li>Connect FPGA board to the computer using main connection cable provided
by the board manufacturers.  Make sure to put USB cable to the right jack
when ambiguity exists (such as in <i>Terasic DE2-115</i> board).</li>

<li>Make sure to power the FPGA board (turn on the power switch) before
connecting the UART cable from USB-to-UART connector to the computer. 
Failing to do so may result in electric damage to the board.</li>

<li>Connect USB-to-UART connector to FPGA board.</li>

</ol>

<p><big><b>3.6.  Run the synthesis and configure the FPGA with the
synthesized MIPSfpga system</b></big></p>

<p>This step is identical to the synthesis step in <i>Lab YP1</i></p>

<p><big><b>3.7.  Go to the lab directory and clean it up</b></big></p>

<p>Under Windows:</p>

<blockquote><pre>
cd programs\lab_yp3
00_clean_all.bat
</pre></blockquote>

<p>Under Linux:</p>

<blockquote><pre>
cd programs/lab_yp3
00_clean_all.sh
</pre></blockquote>

<p><big><b>3.8.  Review the lab program code</b></big></p>

<p>The main program is located in file <i>programs/lab_yp3/main.c</i>. After
reset and running the boot sequence the <i>main()</i> function calls one of
several routines written in assembly language, depending on the position of
three switches in the board: <i>sw[4]</i>, <i>sw[5]</i>, <i>sw[6]</i>:</p>

<blockquote><p>File <i>programs/lab_yp3/main.c</i></p>
<pre>

#include "mfp_memory_mapped_registers.h"

int main ()
{
    MFP_7_SEGMENT_HEX = MFP_SWITCHES >> 4;

    switch (MFP_SWITCHES >> 4)
    {
        case 0: demo_bypass_a_from_alu_instruction        (); break;
        case 1: demo_bypass_b_from_alu_instruction        (); break;
        case 2: demo_bypass_a_and_b_from_alu_instruction  (); break;
        case 3: demo_bypass_a_from_load_instruction       (); break;
        case 4: demo_bypass_b_from_load_instruction       (); break;
        case 5: demo_bypass_a_and_b_from_load_instruction (); break;
    }

    return 0;
}

</pre></blockquote>

<p>The assembly subroutines are located in <i>programs/lab_yp3/demo_bypasses.S</i>.
They written in a way to cause different types of pipeline forwarding
in the simplest fashion, with one forwarded register and without cycle timing
effects due to cache misses. For example, subroutine <i>demo_bypass_a_from_alu_instruction</i>:</p>

<blockquote><p>File <i>programs/lab_yp3/demo_bypasses.S</i></p>
<pre>
        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

        .text

        .global demo_bypass_a_from_alu_instruction

demo_bypass_a_from_alu_instruction:

        li      t0, 0x001
        li      t1, 0x010
1:
        addiu   t1, t0, 1
        addu    t2, t1, t0
        b       1b
        nop

</pre></blockquote>

<p><big><b>3.9.  Prepare the first software run</b></big></p>

<p>Following the procedure described in <i>Lab YP1</i>, compile and link the
program, generate Motorola S-Record file and upload this file into the
memory of the synthesized MIPSfpga-based system on the board.</p>

<p>Under Windows:</p>

<ol>

<li>cd programs\lab_yp3</li>

<li>run 02_compile_and_link.bat</li>

<li>run 08_generate_motorola_s_record_file.bat</li>

<li>run 11_check_which_com_port_is_used.bat</li>

<li>edit 12_upload_to_the_board_using_uart.bat based on the result from the
previous step - set the working port in “set a=” assignment.</li>

<li>Make sure the switches 0, 1, 4, 5, 6 on FPGA board are turned off. 
Switches 0 and 1 control the speed of the clock, while switches 4, 5, and 6
determines which pipeline bypass demo function is called after reset and
boot sequence
 - see <i>3.8.  Review the lab program code</i>.  If the switches 0
and 1 are not off, the loading through UART is not going to work.</li>

<li>run 12_upload_to_the_board_using_uart.bat</li>

</ol>

<p>Under Linux:</p>

<p>If uploading program to the board first time during the current Linux
session, add the current user to <i>dialout</i> Linux group. Enter the
<i>root</i> password when prompted:</p>

<blockquote><pre>
sudo adduser $USER dialout
su - $USER
</pre></blockquote>

<p>After that:</p>

<ol>

<li>cd programs/lab_yp3</li>

<li>run ./02_compile_and_link.sh</li>

<li>run ./08_generate_motorola_s_record_file.sh</li>

<li>run ./11_check_which_com_port_is_used.sh</li>

<li>edit ./12_upload_to_the_board_using_uart.sh based on the result from the
previous step - set the working port in “set a=” assignment</li>

<li>Make sure the switches 0, 1, 4, 5, 6 on FPGA board are turned off. 
Switches 0 and 1 control the speed of the clock, while switches 4, 5, and 6
determines which pipeline bypass demo function is called after reset and
boot sequence
 - see <i>3.8.  Review the lab program code</i>.  If the switches 0
and 1 are not off, the loading through UART is not going to work.</li>

<li>./run 12_upload_to_the_board_using_uart.sh</li>

</ol>

<p><big><b>3.10. The first run</b></big></p>

<ol>

<li>Set the switches 4, 5 and 6 on FPGA board to off position. Such setting
means that after the reset the program will run assembly demo number 0. Make
sure the switches 0 and 1 are off, otherwise the boot sequence (a sequence
of processor instructions before <i>main</i> function) will take too long,
since these switches control the clock frequency.</li>

<li><p>Reset the processor.  The reset buttons for each board are listed
in the table below:</p>

<p><table border=1 cellpadding=10 cellspacing=0 rules=all>
<tr>
<th>Board</th>
<th>Reset button</th>
</tr>
<tr><td>Digilent Basys3</td><td>Up</td></tr>
<tr><td>Digilent Nexys4</td><td>Dedicated CPU Reset</td></tr>
<tr><td>Digilent Nexys4 DDR</td><td>Dedicated CPU Reset</td></tr>
<tr><td>Terasic DE0</td><td>Button/Key 0</td></tr>
<tr><td>Terasic DE0-CV</td><td>Dedicated reset button</td></tr>
<tr><td>Terasic DE0-Nano</td><td>Button/Key 1</td></tr>
<tr><td>Terasic DE1</td><td>Button/Key 0</td></tr>
<tr><td>Terasic DE2-115</td><td>Button/Key 0</td></tr>
</table></p>

</li>

<li>Turn the switch 0 on.  This will switch the system clock from 25 MHz to
0.75 Hz, less than one beat per second.  You should see LED 7 start
blinking, it is connected straight to the system clock.</li>

<li>Check that the seven-segment display shows "0" which is consistent
with switches 4, 5, 6 and the code of the program.</li>

<li><p>Now turn your attention to LEDs 0, 1, 2, 3. They are connected to the following
bypass control signals:</p>

<p><table border=1 cellpadding=10 cellspacing=0 rules=all>
<tr>
<th rowspan=2>LEDs (left to right)</th>
<th colspan=2>Bypass control signals</th>
</tr>
<tr>
<th>Name</th>
<th>Function (according to the comment in Verilog code)</th>
</tr>
<tr><td>3</td><td>mpc_aselres_e</td><td>Bypasses result from M stage (res_m) as source A (rs) for the next instruction</td></tr>
<tr><td>2</td><td>mpc_bselres_e</td><td>Bypasses result from M stage (res_m) as source B (rt) for the next instruction</td></tr>
<tr><td>1</td><td>mpc_aselwr_e</td><td>Bypasses result from A stage (res_w) as source A (rs) for the next instruction</td></tr>
<tr><td>0</td><td>mpc_bselall_e</td><td>Bypasses result from A stage (res_w) as source B (rt) for the next instruction</td></tr>
</table></p>

</li>

<li><p>You can see LED 3 blinking from time to time, indicating bypass of ALU
result to the source A of the next instruction. This is consistent with demo
0 code:</p>

<blockquote><p>File <i>programs/lab_yp3/demo_bypasses.S</i></p>
<pre>
        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1:
        addiu   t1, t0, 1
        addu    t2, t1, t0
        b       1b
        nop

</pre></blockquote>

</li>
</ol>

<p><big><b>3.11. The subsequent runs</b></big></p>

<p>Set the switches 4, 5 and 6 on FPGA board to another position (001), set
the switch 0 to off position, then reset the processor, turn switch 1 on and
observe the patterns of blinking again.Repeat for all 6 bypass demos, with
switches 4, 5 and 6 set to 000, 001, 010, 011, 100, 101. Does the expected
behavior, based on reviewing the assembly code, always matches the pattern?
If not, look to the logic that uses bypass control signals and try to
explain what happens.</p>




system_rtl/mfp_ahb_lite_matrix_config.vh

<img
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-20.39.30.png"
/>

system_rtl/mfp_system.v

<img
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-20.38.43.png"
/>

programs/03_interrupts/main.c no interrupts

<img
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-20.18.06.png"
/>

programs/03_interrupts/main.c interrupt handler

<img
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-20.17.21.png"
/>

programs/03_interrupts/main.c interrupt handler

<img
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-20.18.51.png"
/>

programs/03_interrupts/exceptions.S

<img
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-20.27.09.png"
/>

programs/03_interrupts/program.ld

<img
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-20.31.16.png"
/>

programs/03_interrupts/program.dis interrupt vector

<img
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-21.09.07.png"
/>

programs/03_interrupts/program.dis interrupt handler

<img
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-21.09.56.png"
/>

programs/03_interrupts/program.dis setting up the interrupts

<img
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-21.17.34.png"
/>

programs/03_interrupts/program.dis di / increment / ei

<img
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-21.11.05.png"
/>

<p><big><b>3. Follow-up projects and exercises</b></big></p>

<p>The topic of interrupts is an important one, and we recommend additional
exercises to understand it fully.</p>

<p><big><b>3.1 Exercise: Observe the effect of not disabling the interrupts
around critical section that updates the same variable as the interrupt
handler</b></big></p>

<p>Comment out the assembly commands that enable and disable interrupts
(<i>asm ("di");</i> and <i>asm ("ei")</i>) around incrementing the counter
variable <i>n</i> in <i>main</i> function inside <i>main.c</i> file:</p>

<blockquote><pre>
   // asm ("di");
   n ++;
   // asm ("ei");
</pre></blockquote>

<p>Build and re-run the program, using both fast and slow clocks. Can you
see the difference in system responsiveness to the interrupts? You may
observe cases when the system takes the interrupt and executes the interrupt
service routine that resets the counter. However after returning from the
interrupt, the counter appears not to be reset. Instead it continues to
increment its old value, set before entering the interrupt service routine.
Can you explain what is going on? We recommend to analyze the assembly
output of <i>gcc</i> compiler by running <i>01_compile_c_to_assembly.sh</i>
under Linux or <i>01_compile_c_to_assembly.bat</i> under Windows.</p>

<p><big><b>3.2 Exercise: Synchronize the updates of a counter variable using
<i>LL/SC</i> (Load-Linked / Store-Conditional) pair of
instructions</b></big></p>

<p>MIPS architecture provides a way of synchronizing variable updates
without disabling interrupts, using a special pair of instructions
<i>LL/SC</i> (Load-Linked / Store-Conditional). Create a version of
<i>main.c</i> that uses this feature of the processor instead of
<i>DI/EI</i> pair of instructions used in this lab and <i>Exercise 3.1</i>.
If you are not familiar with <i>LL/SC</i>, you can review the following
materials:</p>

<ol>

<li><i>MIPS32&reg; microAptiv&trade; UP Processor Core Family Software
User's Manual</i>, section 12.3, the descriptions of <i>LL</i> and <i>SC</i>
instructions. This manual is included in <i>MIPSfpga</i> package</li>

<li>Book <i>See MIPS Run, Second Edition, by Dominic Sweetman</i>, sections
<i>5.8.4 Critical Regions with Interrupts Enabled: Semaphores the MIPS
Way</i> and <i>8.5.2 Load-Linked / Store-Conditional</i>.</li>

</ol>

<p>You can implement this exercise using either a function written in
assembly and called from <i>main</i>, or, alternatively, using <i>asm</i>
construct in C with parameters, as described in online GCC documentation (<a
href="https://gcc.gnu.org/onlinedocs">https://gcc.gnu.org/onlinedocs</a>),
see <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">6.45.2
Extended Asm - Assembler Instructions with C Expression Operands</a></p>

<p><big><b>3.3 Investigation: Why do we need <i>volatile</i> qualifier for
the counter variable?</b></big></p>

<p>Review the code of <i>main.c</i>. Why do we need counter variable
<i>n</i> to be declared with <i>volatile</i> qualifier? How does the absense
of this qualifier change the result of program execution? Try to run the
program without <i>volatile</i> with different levels of compiler
optimizations. Is there any change in behavior? Review the code produced by
<i>gcc</i> compiler with different <i>-O</i> settings.</p>

<p><big><b>3.4 Student project and investigation: Non-maskable-interrupt
(NMI) lab</b></big></p>

<p>Study the information about non-maskable-interrupts (NMI) in
<li><i>MIPS32&reg; microAptiv&trade; UP Processor Core Family Software
User's Manual</i> and <li><i>MIPS32&reg; microAptiv&trade; UP Integrator's
Guide</i>, included in <i>MIPSfpga</i> package.</p>

<p>Create a lab that demonstrates NMI interrupts. Investigate using the
internet the history of NMI in different computers. Why was this feature
necessary in the past? How useful is this feature for the modern
applications?</p>

<p><big><b>3.5 Student project: Timer interrupt lab using
<i>Count/Compare</i> pair of Coprocessor 0 registers present inside <i>MIPS
microAptiv UP</i> core</b></big></p>

<p>The timer interrupt is a special kind of hardware interrupt that occurs
regularly, with a set frequency, usually in kilohertz range. Such interrupts
are used to measure time intervals and to implement software multitasking,
including parallel task execution in operating systems.</p>

<p>Read both hardware and software documentation about an embedded timer
interrupt used in MIPS cores in conjunction with the <i>Count/Compare</i>
pair of Coprocessor 0 registers. Is this feature present in MIPSfpga? If
yes, implement a lab that uses this feature. This lab may for example
measure time between pressing some button, or do some computation while the
interrupt service routine polls some input.</p>

<p><big><b>3.6 Student project: Timer interrupt lab using a custom timer
module implemented outside <i>MIPS microAptiv UP</i> core</b></big></p>

<p>Create an alternative implementation of the timer interrupt lab (Exercise
3.5), without using the timer interrupt already implemented in <i>MIPS
microAptiv UP</i> core. In order to create such implementation, write a
custom timer interrupt-generating module in Verilog. Then connect it to one
of hardware interrupt pins, bits of <i>SI_Int</i> external signal.</p>

<p><big><b>3.7 Student project: Programmable timer interrupt lab using a
custom timer module implemented outside <i>MIPS microAptiv UP</i>
core</b></big></p>

<p>Extend the student project 3.6 by interfacing the timer
interupt-generating module not only to system clock, reset and <i>SI_Int</i>
signal, but also to the system's <i>AHB-Lite</i> bus. The goal is that the
frequency of interrupts can be controlled by the software running on
MIPSfpga CPU core. For the details of <i>AHB-Lite</i> interfacing, see
<i>Lab YP2 - Integrating a peripheral: light sensor example</i>.</p>

<p><big><b>3.8 Student project: A variant of programmable timer interrupt
lab that uses multiple counters and interrupt pins</b></big></p>

<p>Create a version of the student project 3.7 that uses multiple counters
to generate hardware interrupts with different frequences on different
hardware pins (bits of the signal <i>SI_Int</i>).</p>

<p><big><b>3.9 Student exercise: Improve the interrupt lab by exposing
program counter (PC) to the outside seven-segment display</b></big></p>

<p>Create a variant of the interrupt lab that connects the processor's
program counter (PC) to the outside multiple-digit seven-segment display.
This connection should be muxed with the regular seven-segment display
output and should be dependent on whether some selected switch or button is
pressed. With this setup, when the system clock is turned into slow mode, it
will be possible to observe how the processor enters interrupt service
routune.</p>

<p><big><b>3.10 Student investigation: Which Coprocessor 0 register bits
should be exposed to outside LEDs to observe interrupts in action in
slow-clock mode?</b></big></p>

<p>Find on the Imagination Technologies website <a
href="http://imgtec.com">http://imgtec.com</a> a manual called <i>MIPS&reg;
Architecture For Programmers Volume III: The MIPS32&reg; and
microMIPS32&trade; Privileged Resource Architecture</i>. Investigate which
Coprocessor 0 register fields are interesting to observe when the processor
core takes an interrupt and enters the interrupt service routine in
slow-clock mode. An example of such field is the <i>EXL</i> (<i>Exception
Level</i>) bit of the Coprocessor 0 <i>Status</i> register.</p>

<p>Modify the core and system RTL to connect these Coprocessor 0 registers
to external LEDs on FPGA board. Some fields, like <i>Status.EXL</i> do not
require changes in core RTL because the original core RTL already outputs
its value to the external pin, <i>SI_EXL</i>. Exposing such fields requires
only changes in the system RTL (<i>system_rtl/mfp_*.v</i> files) . Other
fields may require adding additional ports and connections to the core's RTL
(<i>core_rtl/m14k_*.v</i> files) as well.</p>

<p>Document your changes and create a post on MIPSfpga forum of the
Imagination Technologies website.</p>

<p><big><b>3.11 Advanced student project: Evaluating the usefulness and
applications of Vectored Interrupt (VI) mode in MIPS
architecture</b></big></p>

<p>MIPS microAptiv UP core, used in MIPSfpga, supports three interrupt
modes: Interrupt Compatibility mode, Vectored Interrupt (VI) mode, and
External Interrupt Controller (EIC) mode. So far, the lab and exercises
3.1-3.10 were using the Interrupt Compatibility mode. An alternative
Vectored Interrupt (VI) mode adds the ability to prioritize and vector
interrupts to a handler dedicated to that interrupt. Vectored Interrupt mode
also allows assigning a GPR (General Purpose Register) shadow set for use
during interrupt processing.</p>

<p>Study the documentation and create a lab demonstrating interrupts in
Vectored Interrupt mode. How many clock cycles does this mode save when an
interrupt is taken? When does it make sense to use this mode? Consider very
low-power / low-frequency applications, interrupt response time, usage of
shadow GPR registers (not present in MIPSfpga).</p>

<p>Which interrupt mode is used in Linux? Can you offer an explanation
why?</p>

<p><big><b>3.12 Advanced student project: Building External Interrupt
Controller (EIC)</b></big></p>

<p>The External Interrupt Controller (EIC) mode is another interrupt mode,
supported by MIPS microAptiv UP core used in MIPSfpga. EIC mode redefines
the way interrupts are handled to provide full support for an external
interrupt controller that handles prioritization and vectoring of
interrupts. EIC mode is used in MIPS-based microcontrollers from Microchip
Technology, including some microcontrollers from the Microchip PIC32MZ
family that are built around MIPS microAptiv UP core, the same core used in
MIPSfpga.</p>

<p>The functionality of External Interrupt Controller created by Microchip
is described in Microchip software documentation, the courses taught by
Microchip during Microchip Master Conference, as well as in Imagination,
Microchip and Digilent-sponsored course <i>Connected MCU</i> created by Dr.
Alexander Dean of North Carolina State University.</p>

<p>MIPSfpga allows you to create an alternative External Interrupt
Controller, with its own interrupt scheduling and prioritization, and
compare your solution to the solution from Microchip Technology. This is a
significant research project that can be combined with studies on Real-Time
Operating Systems (RTOS).</p>

<p><big><b>3.13 Medium-to-advanced student project: Create a lab
demonstating multitasking / context switching</b></big></p>

<p>An important application of timer interrupts is to facilitate a variant
of parallel programming called task switching, or context switching. Context
switching is widely used in operating systems, from relatively simple, like
FreeRTOS, to complicated, like Linux.</p>

<p>The idea of context switching is to periodically switch between different
threads of execution, that are also sometimes called processes or tasks. The
"context" is a reference to a set of information associated with the task,
including program counter (PC) and general-purpose registers (GPR). The
switch happens inside the timer interrupt service routine that saves the
current context in some memory structure (called in some systems Process
Control Block - PCB), then restores the context of a different process from
another PCB and exits the timer interrupt into the new thread of
execution.</p>

<p>Create a lab that switches between two different C functions, running in
parallel. You don't need to use any operating system to do this. Just save
and restore all the necessary registers inside the timer interrupt service
routine, and maintain an illusion of parallel execution of two C programs
for the end-user. The end-user would observe the outputs from two programs
on LEDs or other output devices.</p>

<p><big><b>3.14 Advanced student project: Port some open-source RTOS, like
FreeRTOS, to MIPSfpga</b></big></p>

<p>FreeRTOS is a popular real-time operating system, used as an example RTOS
in the course <i>Connected MCU</i> created by Dr.Alexander Dean of North
Carolina State University. The <i>Connected MCU</i> course demonstrates
FreeRTOS on Microchip PIC32MZ microcontroller that uses a processor core
common with MIPSfpga. However PIC32MZ uses External Interrupt Controller
which is absent in the default MIPSfpga system which uses Interrupt
Compatibility Mode. Porting FreeRTOS on MIPSfpga should be an appropriate
project for a graduate student of embedded programming or computer
architecture.</p>

PIPELINE and INTERRUPTS
<p><big><b>Appendix A.  Excerpts from a book <i>See MIPS Run, Second
Edition, by Dominic Sweetman</i> about the interrupt
processing.</b></big></p>

<blockquote>

<p><big><b>Chapter 5.  Exceptions, Interrupts, and
Initialization</b></big></p>

<p>In the MIPS architecture interrupts, traps, system calls, and everything
else that can disrupt the normal flow of execution are called exceptions and
are handled by a single mechanism.  What sort of events are they?<p>

<ul>

<li><p><i>External events</i>: Some event outside the CPU core—that is, from
some real “wire” input signal.  These are interrupts.  (Note: There are some
more obscure noninterrupt external events like bus errors reported on a
read—for now, just assume that they are a special sort of interrupt). 
Interrupts are used to direct the attention of the CPU to some external
event: an essential feature of an OS that attends to more than one different
event at a time.  Interrupts are the only exception conditions that arise
from something independent of the CPU’s normal instruction stream.  Since
you can’t avoid interrupts just by being careful, there have to be software
mechanisms to inhibit the effect of interrupts when necessary.</p></li>

<li><p><i>Memory translation exceptions</i>: These happen when an address
needs to be translated, but no valid translation is available to the
hardware or perhaps on a write to a write-protected page.</p>

<p>The OS must decide whether such an exception is an error or not.  If the
exception is a symptom of an application program stepping outside its
permitted address space, it will be fixed by terminating the application to
protect the rest of the system.  The more common benign memory translation
exceptions can be used to initiate operating system functions as complex as
a complete demand-paged virtual memory system or as simple as extending the
space available for a stack.</p></li>

<li><p><i>Other unusual program conditions for the kernel to fix</i>:
Notable among these are conditions resulting from floating-point
instructions, where the hardware is unable to cope with some difficult and
rare combination of operation and operands and is seeking the services of a
software emulator.  This category is fuzzy, since different kernels have
different ideas about what they’re willing to fix.  An unaligned load may be
an error on one system and something to be handled in software on
another.</p></li>

<li><p><i>Program or hardware-detected errors</i>: This includes nonexistent
instructions, instructions that are illegal at user-privilege level,
coprocessor instructions executed with the appropriate SR flag disabled,
integer overflow, address alignment errors, and accesses outside
<i>kuseg</i> in user mode.</p></li>

<li><p><i>Data integrity problems</i>: Many MIPS CPUs continually check data
on the bus or data coming from the cache for a per-byte parity or for word-
wide error-correcting code.  Cache or parity errors generate an exception in
CPUs that support data checking.</p></li>

<li><p><i>System calls and traps</i>: These are instructions whose whole
purpose is to generate recognizable exceptions; they are used to build
software facil- ities in a secure way (system calls, conditional traps
planted by careful code, and breakpoints).</p></li>

</ul>

</blockquote>

<blockquote>

<p><big><b>5.3 Exception Vectors: Where Exception Handling
Starts</b></big></p>

<p>.  .  .  .  .  .  .  .  .  .</p>

<p>Here’s what a MIPS CPU does when it decides to take an exception:</p>

<ol>

<li>It sets up <b>EPC</b> to point to the restart location.</li>

<li>It sets <b>SR(EXL)</b>, which forces the CPU into kernel
(high-privilege) mode and disables interrupts.</li>

<li><b>Cause</b> is set up so that software can see the reason for the
exception.  On address exceptions, <b>BadVAddr</b> is also set.  Memory
management system exceptions set up some of the MMU registers too; more
details are given in Chapter 6.</li>

<li>The CPU then starts fetching instructions from the exception entry
point, and everything else is up to software.</li>

</ol>

<p>.  .  .  .  .  .  .  .  .  .</p>

<p><big><b>5.5 Returning from an Exception</b></big></p>

<p>The return of control to the exception victim and the change (if
required) back from kernel to a lower-privilege level must be done at the
same time (“atomically,” in the jargon of computer science).  It would be a
security hole if you ran even one instruction of application code at
kernel-privilege level; on the other hand, the attempt to run a kernel
instruction with user privileges would lead to a fatal exception.</p>

<p>MIPS CPUs have an instruction, <b>eret</b>, that does the whole job; it
both clears the <b>SR(EXL)</b> bit and returns control to the address stored
in <b>EPC</b>.</p>

</blockquote>

<blockquote>

<p><big><b>5.8.1 Interrupt Resources in MIPS CPUs</b></big></p>

<p>MIPS CPUs have a set of eight independent (Note: Not so independent if
you’re using EIC mode; see section 5.8.5.) interrupt bits in their
<b>Cause</b> register.  On most CPUs you’ll find five or six of these are
signals from external logic into the CPU, while two of them are purely
software accessible.  The on-chip counter/timer (made of the <b>Count</b>
and <b>Compare</b> registers, described in section 3.3.5) will be wired to
one of them; it’s sometimes possible to share the counter/timer interrupt
with an external device, but rarely a good idea to do so.</p>

<p>An active level on any input signal is sensed in each cycle and will
cause an exception if enabled.</p>

<p>The CPU’s willingness to respond to an interrupt is affected by bits in
<b>SR</b>.</p>

<p>There are three relevant fields:</p>

<ul>

<li>The global interrupt enable bit <b>SR(IE)</b> must be set to 1, or no
interrupt will be serviced.</li>

<li>The <b>SR(EXL)</b> (exception level) and <b>SR(ERL)</b> (error level)
bits will inhibit interrupts if set (as one of them will be immediately
after any exception).</li>

<li>The status register also has eight individual interrupt mask bits
<b>SR(IM)</b>, one for each interrupt bit in <b>Cause</b>.  Each
<b>SR(IM)</b> bit should be set to 1 to enable the corresponding interrupt
so that programs can determine exactly which interrupts can happen and which
cannot.</li>

</ul>

<p>To discover which interrupt inputs are currently active, you look inside
the <b>Cause</b> register.  Note that these are exactly that—current
levels—and do not necessarily correspond to the signal pattern that caused
the interrupt exception in the first place.  The active input levels in
<b>Cause(IP)</b> and the masks in <b>SR(IM)</b> are helpfully aligned to the
same bit positions, in case you want to “and” them together.  The software
interrupts are at the lowest positions, and the hardware interrupts are
arranged in increasing order.</p>

<p>In architectural terms, all interrupts are equal.  (Note: That’s not
quite true in vectored interrupt and “EIC mode,” described in section 5.8.5,
but they’re not widely used).  When an interrupt exception is taken, an
older CPU uses the “general” exception entry point—though MIPS 32/64 CPUs
and some other modern CPUs offer an optional distinct exception entry point
reserved for interrupts, which can save a few cycles.  You can select this
with the <b>Cause(IV)</b> register bit.</p>

<p>Interrupt processing proper begins after you have received an exception
and discovered from <b>Cause(ExcCode)</b> that it was a hardware interrupt. 
Consulting <b>Cause(IP)</b>, we can find which interrupt is active and thus
which device is signaling us.  Here is the usual sequence:</p>

<ul>

<li><p>Consult the <b>Cause</b> register IP field and logically “and” it
with the current interrupt masks in <b>SR(IM)</b> to obtain a bit map of
active, enabled interrupt requests.  There may be more than one, any of
which would have caused the interrupt.</p></li>

<li><p>Select one active, enabled interrupt for attention.  Most OSs assign
the different inputs to fixed priorities and deal with the highest priority
first, but it is all decided by the software.</p></li>

<li><p>You need to save the old interrupt mask bits in <b>SR(IM)</b>, but
you probably already saved the whole <b>SR</b> register in the main
exception routine.</p></li>

<li><p>Change <b>SR(IM)</b> to ensure that the current interrupt and all
interrupts your software regards as being of equal or lesser priority are
inhibited.</p></li>

<li><p>If you haven’t already done it in the main exception routine, save
the state (user registers, etc.) required for nested exception
processing.</p></li>

<li><p>Now change your CPU state to that appropriate to the higher-level
part of the interrupt handler, where typically some nested interrupts and
exceptions are permitted.</p>

<p>In all cases, set the global interrupt enable bit <b>SR(IE)</b> to allow
higher priority interrupts to be processed.  You’ll also need to change the
CPU privilege-level field <b>SR(KSU)</b> to keep the CPU in kernel mode as
you clear exception level and, of course, clear <b>SR(EXL)</b> itself to
leave exception mode and expose the changes made in the status
register.</p></li>

<li><p>Call your interrupt routine.</p></li>

<li><p>On return you’ll need to disable interrupts again so you can restore
the preinterrupt values of registers and resume execution of the interrupted
task.  To do that you’ll set <b>SR(EXL)</b>.  But in practice you’re likely
to do this implicitly when you restore the just-after-exception value of the
whole <b>SR</b> register, before getting into your end-of-exception
sequence.</p></li>

</ul>

<p>When making changes to <b>SR</b>, you need to be careful about changes
whose effect is delayed due to the operation of the pipeline — “CP0
hazards.” See section 3.4 for more details and how to program around the
hazards.</p>

</blockquote>
</body>
</html>
